# 복잡도

* **복잡도(Complexity)** : 알고리즘의 성능
  * *시간 복잡도(Time Complexity)* : 알고리즘을 위해 필요한 연산의 횟수
  * *공간 복잡도(Space Complexity)* : 알고리즘을 위해 필요한 메모리의 양
  * *복잡도가 낮을수록 좋은 알고리즘이다.*

* 시간 복잡도와 공간 복잡도는 일종의 거래 관계(Trade-off)가 성립한다.
  * 메모리 소모 상승 => 연산 횟수 감소 : *메모이제이션(Memoization) 기법*

<br>

## 시간 복잡도

* 시간 복잡도를 표현할 때는 **빅오(Big-O)** 표기법을 사용한다.

* **빅오 표기법** : 가장 빠르게 증가하는 항만 고려하는 표기법.
  * **예시 1)**

    ```java
    public static void main(String[] args) {
      int[] array = new int[]{3, 5, 1, 2, 4};
      int sum = 0;

      for (int i = 0; i < array.length; i++) {
        sum += array[i];
      }

      System.out.println(sum);
    }
    ```

    * N개의 데이터를 하나씩 확인하며 그 값을 합계 변수에 더해준다.
    * 시간 복잡도 : **O(N)**
      * 출력하는 부분은 N이 커짐에 따라서 무시할 정도로 작아지기 때문에 고려하지 않는다.
    
  * **예시 2)**

    ```java
    int a = 5;
    int b = 3;
    print(a + b);
    ```

    * 상수 연산이므로 시간 복잡도는 **O(1)** 이다.

  * **예시 3)**

    ```java
    for (int j = 0; j < array.length; j++) {
      for (int i = 0; i < array.length; i++) {
        sum += array[i] * array[j];
      }
    }
    ```

    * 2중 반복문이기 때문에 N x N 만큼의 연산이 필요하다.
    * 시간 복잡도: **O(N^2^)** 

* 시간 복잡도를 계산할 때, 최악의 경우의 시간 복잡도를 우선적으로 고려해야 한다.

<br>

### 시간 복잡도에 따라서 부르는 명칭

| 빅오 표기법 | 명칭                     |
| ----------- | ------------------------ |
| O(1)        | 상수 시간(Constant time) |
| O(logN)     | 로그 시간(Log time)      |
| O(N)        | 선형 시간                |
| O(NlogN)    | 로그 선형 시간           |
| O(N^2^)     | 이차 시간                |
| O(N^3^)     | 삼차 시간                |
| O(N^4^)     | 사차 시간                |

<br>

차수가 작은 항들을 완전히 무시하는 것도 곤란하다.

* ex) 3N^3^ + 5N^2^ + 1,000,000 에서 N = 10 일때, 1,003,500 이므로 상수의 영향이 크다. 
* 그러므로, 차수가 작아도 완전히 무시할수는 없다.

<br>

### 시간 복잡도 분석은 문제 풀이의 핵심이다.

예를 들어 데이터의 개수가 **N이 1,000만 개를 넘어가며 시간 제한이 1초라면,** 대략 최악의 경우 **O(N)** 의 시간 복잡도로 동작하는 알고리즘을 작성해야 할 것이라고 예상할 수 있다.

혹은 **데이터 크기나 탐색 범위가 100억이나 1,000억을 넘어가는 경우** **O(logN)** 의 시간 복잡도를 갖는 알고리즘을 작성해야 할 것 이다.

* *시간 제한이 1초인 문제에 대한 예시들*

  | N의 범위        | 시간 복잡도 |
  | --------------- | ----------- |
  | N <= 500        | O(N^3^)     |
  | N <= 2,000      | O(N^2^)     |
  | N <= 100,000    | O(NlogN)    |
  | N <= 10,000,000 | O(N)        |

<br>

## 공간 복잡도

코딩 테스트 문제에서 보이는 '시간 제한 1초, 메모리 제한 128MB' 와 같은 문장은 시간 복잡도와 공간 복잡도를 함께 제한하기 위하여 명시하는 것이다.

* **크기 예시들**
  * int a[1000] : 4KB
  * int a[1000000] : 4MB
  * int a\[2000]\[2000] :16MB

코딩 테스트에서는 보통 메모리 사용량을 128 ~ 512 MB 정도로 제한한다. 즉, **데이터의 개수가 1,000만 단위가 넘어가지 않도록 알고리즘 설계를 해야 한다.** 

만약 배열의 크기가 1,000만 단위 이상이라면 자신이 알고리즘을 잘못 설계한 것이 아닌지 고민해봐야 한다.

<br>

## 시간과 메모리 측정

자신이 설계한 알고리즘의 성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.

<br>

## 정리

코딩 테스트에서 문제를 풀 때는 가독성을 해치지 않는 선에서 최대한 복잡도가 낮게 프로그램을 작성해야 한다.